<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WAVRUNNR CELL SYNTH</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            background-color: #0a0a0c;
            color: #e0e0e0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        /* Main layout structure */
        #app-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            width: 100%;
        }
        #main-container {
            flex-grow: 1; /* Canvas container takes up available space */
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }
        #title-header {
            position: absolute;
            top: 20px;
            left: 30px;
            font-size: 1.5em;
            font-weight: 200;
            letter-spacing: 4px;
            color: #ffffff;
            opacity: 0.9;
            z-index: 100;
            text-shadow: 0 0 10px rgba(0,0,0,0.7);
        }
        #start-button {
            position: absolute;
            font-size: 2em;
            padding: 20px 40px;
            background-color: rgba(26, 26, 28, 0.8);
            border: 1px solid #777;
            color: #e0e0e0;
            cursor: pointer;
            transition: all 0.2s ease;
            z-index: 200;
            backdrop-filter: blur(5px);
        }
        #start-button:hover {
            background-color: rgba(42, 42, 46, 0.9);
            border-color: #aaa;
        }
        
        /* New Controls Styling */
        #controls-container {
            flex-shrink: 0; /* Prevent controls from shrinking */
            background-color: #1a1a1c;
            border-top: 1px solid #333;
            width: 100%;
            z-index: 101;
            position: relative;
        }
        #tab-buttons {
            display: flex;
            justify-content: center;
            background-color: #111214;
        }
        .tab-btn {
            padding: 10px 20px;
            cursor: pointer;
            background: none;
            border: none;
            border-bottom: 2px solid transparent;
            color: #aaa;
            font-family: inherit;
            font-size: 0.9em;
            transition: all 0.2s ease;
        }
        .tab-btn:hover {
            background-color: #252830;
            color: #fff;
        }
        .tab-btn.active {
            color: #fff;
            border-bottom: 2px solid #6c73ff;
        }
        #tab-panels {
            padding: 15px;
            background-color: rgba(26, 26, 28, 0.8);
            max-height: 150px; /* Adjust as needed */
            overflow-y: auto;
        }
        .tab-panel {
            display: none; /* Hide panels by default */
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            align-items: flex-start;
        }
        .tab-panel.active {
            display: flex; /* Show active panel */
        }

        /* "Show All" mode styles */
        #show-tabs-btn {
            display: none;
            width: 100%;
            padding: 8px;
            background-color: #111214;
            border: none;
            border-bottom: 1px solid #333;
            color: #fff;
            cursor: pointer;
        }
        #controls-container.show-all-mode #tab-buttons {
            display: none;
        }
        #controls-container.show-all-mode #show-tabs-btn {
            display: block;
        }
        #controls-container.show-all-mode .tab-panel {
            display: flex;
            border-bottom: 1px solid #444;
            padding-bottom: 15px;
            margin-bottom: 15px;
        }
         #controls-container.show-all-mode .tab-panel:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        /* Control elements styling */
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        .control-group label {
            font-size: 0.75em;
            margin-bottom: 2px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #aaa;
        }
        input[type="range"] { width: 100px; }
        button.control-button, select.control-button {
            background: #252830;
            border: 1px solid #454850;
            color: #ccc;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
            font-family: inherit;
            font-size: 0.9em;
        }
        button.control-button:hover, select.control-button:hover { background: #353840; }
        button.control-button.selected { background-color: #5a5f70; border-color: #aab; }

        /* Guide Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background: #1e1e22;
            padding: 30px;
            border-radius: 10px;
            border: 1px solid #555;
            max-width: 500px;
            position: relative;
            color: #ddd;
            line-height: 1.6;
        }
        .modal-content h2 {
            margin-top: 0;
            color: #fff;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
        }
        .modal-content p { margin: 10px 0; }
        .modal-content strong { color: #8a90ff; }
        .close-btn {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 2em;
            background: none;
            border: none;
            color: #aaa;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="app-container">
        <div id="main-container">
            <h1 id="title-header">WAVRUNNR CELL SYNTH</h1>
            <canvas id="synth-canvas"></canvas>
            <button id="start-button">Begin</button>
        </div>

        <div id="controls-container" style="display: none;">
            <button id="show-tabs-btn">Show Tabs</button>
            <div id="tab-buttons">
                <button class="tab-btn active" data-tab="master">Master</button>
                <button class="tab-btn" data-tab="simulation">Simulation</button>
                <button class="tab-btn" data-tab="musical">Musical</button>
                <button class="tab-btn" data-tab="voices">Voices</button>
                <button class="tab-btn" data-tab="shaping">Sound Shaping</button>
                <button class="tab-btn" data-tab="fx">Global FX</button>
                <button class="tab-btn" id="show-all-btn">Show All</button>
                <button class="tab-btn" id="guide-btn">?</button>
            </div>
            <div id="tab-panels">
                <div class="tab-panel active" id="tab-master">
                    <div class="control-group"> <button class="control-button" id="play-pause-btn">Play</button> </div>
                    <div class="control-group"> <button class="control-button" id="randomize-btn">Randomize</button> </div>
                    <div class="control-group"> <button class="control-button" id="clear-btn">Clear</button> </div>
                    <div class="control-group"> <label for="speed-slider">Speed</label> <input type="range" id="speed-slider" min="2" max="20" value="8" step="1"> </div>
                    <div class="control-group"> <label for="cell-size-slider">Cell Size</label> <input type="range" id="cell-size-slider" min="5" max="25" value="10" step="1"> </div>
                    <div class="control-group"> <label for="graphics-select">Graphics</label> <select id="graphics-select" class="control-button"><option value="high">High</option><option value="low">Low</option></select> </div>
                </div>
                <div class="tab-panel" id="tab-simulation">
                    <div class="control-group"> <label for="brush-select">Brush</label> <select id="brush-select" class="control-button"> <option value="draw">Draw</option> <option value="glider">Glider</option> <option value="lwss">LWSS</option> <option value="blinker">Blinker</option> <option value="pulsar">Pulsar</option> <option value="gosperGliderGun">Gosper Glider Gun</option></select> </div>
                    <button class="control-button" id="species-toggle-btn">Species: A</button>
                    <div class="control-group"> <label for="rules-select">Rules</label> <select id="rules-select" class="control-button"> <option value="gameOfLife">Game of Life</option> <option value="highLife">HighLife</option> <option value="dayAndNight">Day & Night</option></select> </div>
                    <div class="control-group"> <label for="density-slider">Density</label> <input type="range" id="density-slider" min="0.05" max="0.8" value="0.2" step="0.01"> </div>
                    <button class="control-button selected" id="collision-toggle-btn">Collision: On</button>
                </div>
                <div class="tab-panel" id="tab-musical">
                    <div class="control-group"> <label for="scale-select">Scale</label> <select id="scale-select" class="control-button"> <option value="cMinorPentatonic">C Minor Pentatonic</option> <option value="gMajor">G Major</option> <option value="fLydian">F Lydian</option> <option value="aBlues">A Blues</option> <option value="dDorian">D Dorian</option> <option value="cMajorPentatonic">C Major Pentatonic</option> <option value="gPhrygianDominant">G Phrygian Dominant</option> <option value="cPrometheus">C Prometheus</option></select> </div>
                    <div class="control-group"> <label for="octave-select">Octave</label> <select id="octave-select" class="control-button"> <option value="-1">Down</option> <option value="0" selected>Default</option> <option value="1">Up</option> </select> </div>
                </div>
                <div class="tab-panel" id="tab-voices">
                    <div class="control-group"> <label for="pad-sound-select">Pad</label> <select id="pad-sound-select" class="control-button"> <option value="warmSine">Warm Sine</option> <option value="cloudPad">Cloud Pad</option> <option value="brightSaw">Bright Saw</option> </select> </div>
                    <div class="control-group"> <label for="volume-slider">Pad Vol</label> <input type="range" id="volume-slider" min="0" max="1" value="0.7" step="0.01"> </div>
                    <div class="control-group"> <label for="pluck-sound-select">Pluck</label> <select id="pluck-sound-select" class="control-button"> <option value="softTriangle">Soft Triangle</option> <option value="kalimba">Kalimba</option> <option value="metalFm">Metal FM</option> </select> </div>
                    <div class="control-group"> <label for="pluck-volume-slider">Pluck Vol</label> <input type="range" id="pluck-volume-slider" min="0" max="1" value="0.5" step="0.01"> </div>
                    <div class="control-group"> <label for="pluck-chance-slider">Pluck %</label> <input type="range" id="pluck-chance-slider" min="0" max="100" value="100" step="1"> </div>
                    <div class="control-group"> <label for="pluck-detune-slider">Pluck Detune</label> <input type="range" id="pluck-detune-slider" min="0" max="100" value="0" step="1"> </div>
                    <div class="control-group"> <label for="collision-sound-select">Collision</label> <select id="collision-sound-select" class="control-button"> <option value="boing">Boing</option> <option value="laser">Laser</option> <option value="lowTom">Low Tom</option> </select> </div>
                    <div class="control-group"> <label for="collision-volume-slider">Coll Vol</label> <input type="range" id="collision-volume-slider" min="0" max="1" value="0.5" step="0.01"> </div>
                </div>
                <div class="tab-panel" id="tab-shaping">
                    <div class="control-group"> <label for="swell-time-slider">Swell Time</label> <input type="range" id="swell-time-slider" min="0.1" max="10" value="4" step="0.1"> </div>
                    <div class="control-group"> <label for="swell-curve-select">Swell Curve</label> <select id="swell-curve-select" class="control-button"> <option value="exponential" selected>Exponential</option> <option value="linear">Linear</option> <option value="sine">Sine</option> </select> </div>
                    <div class="control-group"> <label for="lfo-speed-slider">LFO Speed</label> <input type="range" id="lfo-speed-slider" min="0.1" max="10" value="2" step="0.1"> </div>
                    <div class="control-group"> <label for="lfo-depth-slider">LFO Depth</label> <input type="range" id="lfo-depth-slider" min="0" max="1000" value="0" step="10"> </div>
                </div>
                <div class="tab-panel" id="tab-fx">
                    <div class="control-group"> <label for="filter-slider">Filter</label> <input type="range" id="filter-slider" min="200" max="8000" value="1500" step="10"> </div>
                    <div class="control-group"> <label for="stereo-width-slider">Stereo</label> <input type="range" id="stereo-width-slider" min="0" max="100" value="100" step="1"> </div>
                    <div class="control-group"> <label for="chorus-slider">Chorus</label> <input type="range" id="chorus-slider" min="0" max="1" value="0.2" step="0.01"> </div>
                    <div class="control-group"> <label for="delay-slider">Delay</label> <input type="range" id="delay-slider" min="0" max="0.8" value="0.3" step="0.01"> </div>
                    <div class="control-group"> <label for="reverb-slider">Reverb</label> <input type="range" id="reverb-slider" min="0" max="1" value="0.5" step="0.01"> </div>
                    <div class="control-group"> <label for="bloom-slider">Bloom</label> <input type="range" id="bloom-slider" min="0" max="1" value="0" step="0.01"> </div>
                </div>
            </div>
        </div>
    </div>

    <div id="guide-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <button id="close-guide-btn" class="close-btn">&times;</button>
            <h2>Welcome to WAVRUNNR's Cell Synth</h2>
            <p>This is a generative ambient synth where evolving cells create music.</p>
            <p><strong>To start:</strong> Press <strong>Play</strong>. Click and drag on the grid to draw new cells. They will evolve and create sound based on their position.</p>
            <ul>
                <li>The <strong>vertical position</strong> of a cell determines its musical pitch.</li>
                <li>The <strong>horizontal position</strong> determines its stereo panning (left/right).</li>
                <li>Use the <strong>Brush</strong> dropdown to stamp classic patterns like 'Glider'.</li>
                <li>Experiment with different <strong>Rules</strong> and <strong>Scales</strong> to completely change the mood.</li>
            </ul>
            <p><strong>Note:</strong> If you experience any audio issues or strange behavior, please try refreshing the page.</p>
            <p>Have fun exploring the sounds!</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const startButton = document.getElementById('start-button');
            const mainContainer = document.getElementById('main-container');
            const controlsContainer = document.getElementById('controls-container');
            const canvas = document.getElementById('synth-canvas');
            const ctx = canvas.getContext('2d');

            let initialized = false, isPlaying = false, isDrawing = false, firstPlay = true, currentHueA = 0, currentHueB = 180;
            let collisionOn = true;
            let activeSpecies = 'A';
            let graphicsQuality = 'high';
            const maxCellAge = 50;
            let synths = {}; 
            let currentPadKey, currentPluckKey, currentCollisionKey;
            let filter, preFxGain, chorus, delay, reverb, bloomReverb, limiter, compressor, lfo;
            let cellSize = 10;
            let gridWidth, gridHeight, grid, nextGrid, mainLoop;
            let padsToPlay = [], plucksToPlay = [], collisionsToPlay = [];
            let particles = [];
            let collisionsToVisualize = [];
            
            const scales = {
                cMinorPentatonic: ["C2", "Eb2", "F2", "G2", "Bb2","C3", "Eb3", "F3", "G3", "Bb3","C4", "Eb4", "F4", "G4", "Bb4","C5", "Eb5", "F5", "G5", "Bb5"],
                gMajor: ["G2", "A2", "B2", "C3", "D3", "E3", "F#3","G3", "A3", "B3", "C4", "D4", "E4", "F#4","G4", "A4", "B4", "C5", "D5", "E5", "F#5"],
                fLydian: ["F2", "G2", "A2", "B2", "C3", "D3", "E3","F3", "G3", "A3", "B3", "C4", "D4", "E4","F4", "G4", "A4", "B4", "C5", "D5", "E5"],
                aBlues: ["A2", "C3", "D3", "Eb3", "E3", "G3","A3", "C4", "D4", "Eb4", "E4", "G4","A4", "C5", "D5", "Eb5", "E5", "G5"],
                dDorian: ["D2", "E2", "F2", "G2", "A2", "B2", "C3","D3", "E3", "F3", "G3", "A3", "B3", "C4","D4", "E4", "F4", "G4", "A4", "B4", "C5"],
                cMajorPentatonic: ["C2", "D2", "E2", "G2", "A2", "C3", "D3", "E3", "G3", "A3", "C4", "D4", "E4", "G4", "A4", "C5", "D5", "E5", "G5", "A5"],
                gPhrygianDominant: ["G2", "Ab2", "B2", "C3", "D3", "Eb3", "F3", "G3", "Ab3", "B3", "C4", "D4", "Eb4", "F4", "G4", "Ab4", "B4", "C5", "D5", "Eb5", "F5"],
                cPrometheus: ["C2", "D2", "E2", "F#2", "A2", "Bb2", "C3", "D3", "E3", "F#3", "A3", "Bb3", "C4", "D4", "E4", "F#4", "A4", "Bb4", "C5", "D5", "E5", "F#5", "A5", "Bb5"]
            };
            let currentScaleKey = 'cMinorPentatonic';
            let octaveShift = 0;

            const rules = {
                gameOfLife: { b: [3], s: [2, 3] }, 
                highLife: { b: [3, 6], s: [2, 3] },
                dayAndNight: { b: [3, 6, 7, 8], s: [3, 4, 6, 7, 8] }, 
                seeds: { b: [2], s: [] }
            };
            let currentRuleKey = 'gameOfLife';
            
            const patterns = {
                glider: [[0, 1, 0], [0, 0, 1], [1, 1, 1]],
                lwss: [[1, 0, 0, 1, 0], [0, 0, 0, 0, 1], [1, 0, 0, 0, 1], [0, 1, 1, 1, 1]],
                blinker: [[1, 1, 1]],
                pulsar: [
                    [0,0,1,1,1,0,0,0,1,1,1,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [1,0,0,0,0,1,0,1,0,0,0,0,1],
                    [1,0,0,0,0,1,0,1,0,0,0,0,1],
                    [1,0,0,0,0,1,0,1,0,0,0,0,1],
                    [0,0,1,1,1,0,0,0,1,1,1,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,1,1,1,0,0,0,1,1,1,0,0],
                    [1,0,0,0,0,1,0,1,0,0,0,0,1],
                    [1,0,0,0,0,1,0,1,0,0,0,0,1],
                    [1,0,0,0,0,1,0,1,0,0,0,0,1],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,1,1,1,0,0,0,1,1,1,0,0]
                ],
                gosperGliderGun: [
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
                    [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
                    [1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [1,1,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
                ]
            };
            let currentBrush = 'draw';

            const mapValue = (v, iA, iB, oA, oB) => ((v - iA) * (oB - oA)) / (iB - iA) + oA;
            
            class PannableSynth extends Tone.Synth {
                constructor(options) { super(options); this.panner = new Tone.Panner(0).connect(filter); this.output.connect(this.panner); }
                set pan(value) { this.panner.pan.rampTo(value, 0.05); }
                dispose() { if(this.panner) {this.panner.dispose();} return super.dispose(); }
            }
            class PannableAMSynth extends Tone.AMSynth {
                constructor(options) { super(options); this.panner = new Tone.Panner(0).connect(filter); this.output.connect(this.panner); }
                set pan(value) { this.panner.pan.rampTo(value, 0.05); }
                dispose() { if(this.panner) {this.panner.dispose();} return super.dispose(); }
            }
            class PannableFMSynth extends Tone.FMSynth {
                constructor(options) { super(options); this.panner = new Tone.Panner(0).connect(filter); this.output.connect(this.panner); }
                set pan(value) { this.panner.pan.rampTo(value, 0.05); }
                dispose() { if(this.panner) {this.panner.dispose();} return super.dispose(); }
            }
            class PannableMembraneSynth extends Tone.MembraneSynth {
                constructor(options) { super(options); this.panner = new Tone.Panner(0).connect(filter); this.output.connect(this.panner); }
                set pan(value) { this.panner.pan.rampTo(value, 0.05); }
                dispose() { if(this.panner) {this.panner.dispose();} return super.dispose(); }
            }
            
            const soundBank = {
                pads: {
                    warmSine: { voice: PannableSynth, options: { volume: -8, oscillator: { type: "fatsine" }, envelope: { attack: 4, decay: 1.5, sustain: 0.8, release: 10, attackCurve: 'exponential' } } },
                    cloudPad: { voice: PannableSynth, options: { volume: -16, oscillator: { type: "fatsine", count: 4, spread: 40 }, envelope: { attack: 5, decay: 1.5, sustain: 0.8, release: 10, attackCurve: 'exponential' } } },
                    brightSaw: { voice: PannableAMSynth, options: { volume: -12, harmonicity: 1.5, envelope: { attack: 5, decay: 1, sustain: 1, release: 7 }, modulationEnvelope: { attack: 1, decay: 0.5, sustain: 1, release: 2 } } }
                },
                plucks: {
                    softTriangle: { voice: PannableSynth, options: { volume: -20, oscillator: { type: "triangle" }, envelope: { attack: 0.01, decay: 0.3, sustain: 0.05, release: 0.25 } } },
                    kalimba: { voice: PannableFMSynth, options: { volume: -14, harmonicity: 3, modulationIndex: 5, envelope: { attack: 0.01, decay: 0.8, sustain: 0, release: 0.8 }, modulationEnvelope: { attack: 0.01, decay: 0.3, sustain: 0, release: 0.3 } } },
                    metalFm: { voice: PannableFMSynth, options: { volume: -18, harmonicity: 2, modulationIndex: 3, envelope: { attack: 0.01, decay: 0.5, sustain: 0, release: 0.5 }, modulationEnvelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.2 } } }
                },
                collisions: {
                    boing: { voice: PannableMembraneSynth, options: { volume: -10, octaves: 4, pitchDecay: 0.01 } },
                    laser: { voice: PannableSynth, options: { volume: -16, oscillator: { type: 'sawtooth' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.3 } } },
                    lowTom: { voice: PannableMembraneSynth, options: { volume: -8, pitchDecay: 0.08, octaves: 2, envelope: { attack: 0.01, decay: 0.5, sustain: 0, release: 0.5 } } }
                }
            };

            async function init() {
                try {
                    if (initialized) return;
                    initialized = true;
                    await Tone.start();
                    setupAudio(); 
                    setupGrid(); 
                    setupControls(); 
                    resizeCanvas();
                    window.addEventListener('resize', resizeCanvas);
                    Tone.Draw.schedule(draw, Tone.now());
                    startButton.style.display = 'none';
                    controlsContainer.style.display = 'block';

                } catch (e) {
                    console.error("CRITICAL ERROR during initialization:", e);
                }
            }
            startButton.addEventListener('click', init);
            
            function keepAudioContextAlive() {
                if (initialized && Tone.context.state === 'suspended') {
                    Tone.context.resume();
                }
            }
            ['mousedown', 'keydown', 'touchstart'].forEach(eventName => {
                document.body.addEventListener(eventName, keepAudioContextAlive, { passive: true, capture: true });
            });
            setInterval(keepAudioContextAlive, 2000);


            function setupAudio() {
                limiter = new Tone.Limiter(-0.5).toDestination();
                compressor = new Tone.Compressor(-12, 4).connect(limiter);
                bloomReverb = new Tone.Reverb({ decay: 20, preDelay: 0.05, wet: 0 }).connect(compressor);
                reverb = new Tone.Reverb({ decay: 15, wet: 0.5 }).connect(bloomReverb);
                delay = new Tone.PingPongDelay("8n.", 0.3).connect(reverb);
                chorus = new Tone.Chorus(2, 2.5, 0.2).connect(delay);
                preFxGain = new Tone.Gain(0).connect(chorus); 
                filter = new Tone.Filter(1500, "lowpass").connect(preFxGain);
                lfo = new Tone.LFO({ frequency: 2, min: 0, max: 0 }).connect(filter.frequency);
                
                for (const bank in soundBank) {
                    synths[bank] = {};
                    for (const soundKey in soundBank[bank]) {
                        const sound = soundBank[bank][soundKey];
                        const polyphony = bank === 'pads' ? 16 : 8; // More voices for pads
                        synths[bank][soundKey] = {
                            synth: new Tone.PolySynth({ polyphony, voice: sound.voice, options: sound.options }),
                            gain: new Tone.Gain(0).connect(preFxGain)
                        };
                        synths[bank][soundKey].synth.connect(synths[bank][soundKey].gain);
                    }
                }
                
                currentPadKey = 'warmSine';
                synths.pads[currentPadKey].gain.gain.value = 1; // Set initial pad volume
                currentPluckKey = 'softTriangle';
                synths.plucks[currentPluckKey].gain.gain.value = 1;
                currentCollisionKey = 'boing';
                synths.collisions[currentCollisionKey].gain.gain.value = 1;
            }

            function setupGrid() {
                resizeGrid();
                randomizeGrid();
                mainLoop = new Tone.Loop(time => {
                    Tone.Transport.scheduleOnce((t) => { computeNextGeneration(t); }, Tone.now());
                }, "16n").start(0);
                Tone.Transport.bpm.value = 120;
            }

            function resizeCanvas() {
                canvas.width = mainContainer.clientWidth;
                canvas.height = mainContainer.clientHeight;
                resizeGrid();
            }

            function resizeGrid() {
                gridWidth = Math.floor(canvas.width / cellSize);
                gridHeight = Math.floor(canvas.height / cellSize);
                grid = createEmptyGrid();
                nextGrid = createEmptyGrid();
            }

            function createEmptyGrid() {
                return Array.from({ length: gridHeight }, () => Array(gridWidth).fill(null));
            }

            function randomizeGrid() {
                const density = parseFloat(document.getElementById('density-slider').value);
                for (let y = 0; y < gridHeight; y++) {
                    for (let x = 0; x < gridWidth; x++) {
                        if (Math.random() < density) {
                            const species = Math.random() < 0.5 ? 'A' : 'B';
                            grid[y][x] = { species: species, age: 1 };
                        } else {
                            grid[y][x] = null;
                        }
                    }
                }
            }
            
            function getTransposedNote(note, octaveShift) {
                if (octaveShift === 0) return note;
                const matches = note.match(/([A-G]#?b?)(\d+)/);
                if (!matches) return note;
                const noteName = matches[1];
                const octave = parseInt(matches[2], 10);
                return `${noteName}${octave + octaveShift}`;
            }

            function computeNextGeneration(time) {
                padsToPlay = [];
                plucksToPlay = [];
                collisionsToPlay = [];

                let totalAge = 0, liveCellCount = 0;
                const stereoWidth = parseFloat(document.getElementById('stereo-width-slider').value) / 100;
                const currentRule = rules[currentRuleKey];
                const currentScale = scales[currentScaleKey];
                const pluckChanceSlider = parseFloat(document.getElementById('pluck-chance-slider').value) / 100;
                const pluckDetune = parseFloat(document.getElementById('pluck-detune-slider').value);
                
                const pluckChance = pluckChanceSlider * pluckChanceSlider;

                for (let y = 0; y < gridHeight; y++) {
                    for (let x = 0; x < gridWidth; x++) {
                        const cell = grid[y][x];
                        const neighborsA = countNeighbors(y, x, 'A');
                        const neighborsB = countNeighbors(y, x, 'B');

                        const canAbeBorn = currentRule.b.includes(neighborsA);
                        const canBbeBorn = currentRule.b.includes(neighborsB);

                        const pitchIndex = Math.floor(mapValue(y, gridHeight - 1, 0, 0, currentScale.length - 1));
                        const baseNote = currentScale[pitchIndex];
                        const transposedNote = getTransposedNote(baseNote, octaveShift);
                        const fullPanValue = mapValue(x, 0, gridWidth, -1, 1);
                        const finalPanValue = fullPanValue * stereoWidth;
                        const detuneValue = (Math.random() - 0.5) * 2 * pluckDetune;
                        const noteInfo = { note: transposedNote, pan: finalPanValue, detune: detuneValue };
                        
                        let nextState = cell;

                        if (cell) {
                            const ownNeighbors = cell.species === 'A' ? neighborsA : neighborsB;
                            if (!currentRule.s.includes(ownNeighbors)) {
                                nextState = null;
                                if (Math.random() < pluckChance) plucksToPlay.push({ ...noteInfo, species: cell.species });
                            } else if ((canAbeBorn && cell.species === 'B') || (canBbeBorn && cell.species === 'A')) {
                                nextState = null;
                                collisionsToPlay.push({ ...noteInfo, species: cell.species });
                                collisionsToVisualize.push({ x, y, life: 30 });
                            } else {
                                nextState = { ...cell, age: cell.age + 1 };
                            }
                        } else {
                            if (canAbeBorn && !canBbeBorn) {
                                nextState = { species: 'A', age: 1 };
                                padsToPlay.push(noteInfo);
                            } else if (!canAbeBorn && canBbeBorn) {
                                nextState = { species: 'B', age: 1 };
                                padsToPlay.push(noteInfo);
                            }
                        }

                        nextGrid[y][x] = nextState;
                        if (nextState) {
                            totalAge += nextState.age;
                            liveCellCount++;
                        }
                    }
                }
                
                if (liveCellCount > 0) {
                    const averageAge = totalAge / liveCellCount;
                    const newFilterFreq = mapValue(averageAge, 1, maxCellAge, 8000, 400);
                    const manualFilterMax = parseFloat(document.getElementById('filter-slider').value);
                    const baseFrequency = Math.min(manualFilterMax, newFilterFreq);
                    
                    lfo.min = baseFrequency;
                    lfo.max = baseFrequency + parseFloat(document.getElementById('lfo-depth-slider').value);
                } else {
                    const manualFilterValue = parseFloat(document.getElementById('filter-slider').value);
                    lfo.min = manualFilterValue;
                    lfo.max = manualFilterValue + parseFloat(document.getElementById('lfo-depth-slider').value);
                }

                [grid, nextGrid] = [nextGrid, grid];
                
                const padSynth = synths.pads[currentPadKey].synth;
                const velocity = parseFloat(document.getElementById('volume-slider').value);

                if (padsToPlay.length > 0) {
                    padsToPlay.forEach(noteObj => {
                        padSynth.set({ pan: noteObj.pan });
                        padSynth.triggerAttackRelease(noteObj.note, "2n", time, velocity);
                    });
                }

                const pluckSynth = synths.plucks[currentPluckKey].synth;
                if (plucksToPlay.length > 0) {
                    const sliderValue = parseFloat(document.getElementById('pluck-volume-slider').value);
                    const pluckVelocity = mapValue(sliderValue, 0, 1, 0, 0.5);
                    if (pluckVelocity > 0) {
                        plucksToPlay.forEach(noteObj => {
                            pluckSynth.set({ pan: noteObj.pan, detune: noteObj.detune });
                            pluckSynth.triggerAttackRelease(noteObj.note, "16n", time, pluckVelocity);
                        });
                    }
                }
                
                const collisionSynth = synths.collisions[currentCollisionKey].synth;
                if (collisionOn && collisionsToPlay.length > 0) {
                    const collisionVelocity = parseFloat(document.getElementById('collision-volume-slider').value);
                    if (collisionVelocity > 0) {
                        collisionsToPlay.forEach(noteObj => {
                            collisionSynth.set({ pan: noteObj.pan });
                            collisionSynth.triggerAttackRelease(noteObj.note, "8n", time, collisionVelocity);
                        });
                    }
                }
            }

            function countNeighbors(y, x, species) {
                let count = 0;
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        if (i === 0 && j === 0) continue;
                        const ny = (y + i + gridHeight) % gridHeight;
                        const nx = (x + j + gridWidth) % gridWidth;
                        const neighbor = grid[ny][nx];
                        if (neighbor && neighbor.species === species) count++;
                    }
                }
                return count;
            }
            
            function updateAndDrawParticles() {
                ctx.globalCompositeOperation = 'lighter';
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vx *= 0.97;
                    p.vy *= 0.97;
                    p.life--;
                    if (p.life <= 0) {
                        particles.splice(i, 1);
                    } else {
                        ctx.beginPath();
                        ctx.fillStyle = `hsla(${p.hue}, 100%, 75%, ${p.life / 50})`;
                        ctx.arc(p.x, p.y, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                ctx.globalCompositeOperation = 'source-over';
            }
            
            function updateAndDrawCollisions() {
                for (let i = collisionsToVisualize.length - 1; i >= 0; i--) {
                    const c = collisionsToVisualize[i];
                    c.life--;
                    if (c.life <= 0) {
                        collisionsToVisualize.splice(i, 1);
                    } else {
                        const lifeRatio = c.life / 30;
                        ctx.beginPath();
                        ctx.strokeStyle = `hsla(0, 100%, 100%, ${lifeRatio * 0.7})`;
                        ctx.lineWidth = 1;
                        ctx.arc((c.x + 0.5) * cellSize, (c.y + 0.5) * cellSize, (1 - lifeRatio) * cellSize * 2, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }
            }

            function draw() {
                currentHueA = (currentHueA + 0.5) % 360;
                currentHueB = (currentHueA + 180) % 360;

                ctx.fillStyle = 'rgba(10, 10, 12, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                updateAndDrawCollisions();

                for (let y = 0; y < gridHeight; y++) {
                    for (let x = 0; x < gridWidth; x++) {
                        const cell = grid[y][x];
                        if (cell) {
                            const lightness = 70 - ((cell.age / maxCellAge) * 50);
                            const hue = cell.species === 'A' ? currentHueA : currentHueB;
                            ctx.fillStyle = `hsl(${hue}, 100%, ${lightness}%)`;
                            
                            if (graphicsQuality === 'high') {
                                ctx.shadowBlur = 10;
                                ctx.shadowColor = `hsl(${hue}, 100%, ${lightness}%)`;
                            }
                            ctx.fillRect(x * cellSize, y * cellSize, cellSize - 1, cellSize - 1);
                        }
                    }
                }
                ctx.shadowBlur = 0; 
                
                updateAndDrawParticles();
                Tone.Draw.schedule(draw, Tone.now());
            }
            
            function setupControls() {
                const tabButtons = document.querySelectorAll('.tab-btn');
                const tabPanels = document.querySelectorAll('.tab-panel');

                tabButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        tabButtons.forEach(btn => btn.classList.remove('active'));
                        button.classList.add('active');

                        const targetTab = button.getAttribute('data-tab');
                        tabPanels.forEach(panel => {
                            if (panel.id === `tab-${targetTab}`) {
                                panel.classList.add('active');
                            } else {
                                panel.classList.remove('active');
                            }
                        });
                    });
                });
                
                document.getElementById('graphics-select').addEventListener('change', e => {
                    graphicsQuality = e.target.value;
                });
                
                document.getElementById('cell-size-slider').addEventListener('input', e => {
                    cellSize = parseInt(e.target.value, 10);
                    resizeCanvas();
                });

                document.getElementById('play-pause-btn').addEventListener('click', () => {
                    isPlaying = !isPlaying;
                    const btn = document.getElementById('play-pause-btn');
                    if (isPlaying) { 
                        Tone.Transport.start(); 
                        btn.textContent = "Pause";
                        if (firstPlay) {
                            preFxGain.gain.rampTo(0.7, 1.5); // Slower fade-in
                            lfo.start();
                            firstPlay = false;
                        }
                    } 
                    else { Tone.Transport.pause(); btn.textContent = "Play"; }
                });
                
                const collisionBtn = document.getElementById('collision-toggle-btn');
                collisionBtn.addEventListener('click', () => {
                    collisionOn = !collisionOn;
                    collisionBtn.textContent = `Collision: ${collisionOn ? 'On' : 'Off'}`;
                    collisionBtn.classList.toggle('selected', collisionOn);
                });
                
                const speciesBtn = document.getElementById('species-toggle-btn');
                speciesBtn.addEventListener('click', () => {
                    activeSpecies = activeSpecies === 'A' ? 'B' : 'A';
                    speciesBtn.textContent = `Species: ${activeSpecies}`;
                });
                
                document.getElementById('pad-sound-select').addEventListener('change', e => {
                    const newPadKey = e.target.value;
                    if (newPadKey !== currentPadKey) {
                        synths.pads[currentPadKey].gain.gain.rampTo(0, 0.5);
                        synths.pads[newPadKey].gain.gain.rampTo(1, 0.5);
                        currentPadKey = newPadKey;
                    }
                });
                document.getElementById('pluck-sound-select').addEventListener('change', e => { 
                    const newPluckKey = e.target.value;
                    if (newPluckKey !== currentPluckKey) {
                        synths.plucks[currentPluckKey].gain.gain.rampTo(0, 0.1);
                        synths.plucks[newPluckKey].gain.gain.rampTo(1, 0.1);
                        currentPluckKey = newPluckKey;
                    }
                 });
                document.getElementById('collision-sound-select').addEventListener('change', e => { 
                    const newCollisionKey = e.target.value;
                    if (newCollisionKey !== currentCollisionKey) {
                        synths.collisions[currentCollisionKey].gain.gain.rampTo(0, 0.1);
                        synths.collisions[newCollisionKey].gain.gain.rampTo(1, 0.1);
                        currentCollisionKey = newCollisionKey;
                    }
                });

                document.getElementById('randomize-btn').addEventListener('click', randomizeGrid);
                document.getElementById('clear-btn').addEventListener('click', () => { grid = createEmptyGrid(); });
                document.getElementById('scale-select').addEventListener('change', e => { currentScaleKey = e.target.value; });
                document.getElementById('rules-select').addEventListener('change', e => { currentRuleKey = e.target.value; });
                document.getElementById('octave-select').addEventListener('change', e => { octaveShift = parseInt(e.target.value, 10); });
                document.getElementById('brush-select').addEventListener('change', e => { currentBrush = e.target.value; });
                
                document.getElementById('swell-time-slider').addEventListener('input', e => {
                    const attackTime = parseFloat(e.target.value);
                    for (const key in synths.pads) {
                        if (synths.pads[key]) synths.pads[key].synth.set({ envelope: { attack: attackTime } });
                    }
                });
                document.getElementById('swell-curve-select').addEventListener('change', e => {
                    const curve = e.target.value;
                    for (const key in synths.pads) {
                        if (synths.pads[key]) synths.pads[key].synth.set({ envelope: { attackCurve: curve } });
                    }
                });

                document.getElementById('lfo-speed-slider').addEventListener('input', e => { if(lfo && lfo.frequency) lfo.frequency.value = parseFloat(e.target.value); });
                document.getElementById('lfo-depth-slider').addEventListener('input', e => { if(lfo) lfo.max = parseFloat(document.getElementById('filter-slider').value) + parseFloat(e.target.value); });
                document.getElementById('speed-slider').addEventListener('input', e => { if (mainLoop && mainLoop.frequency) mainLoop.frequency.value = `${parseInt(e.target.value)}n`; });
                document.getElementById('chorus-slider').addEventListener('input', e => { if (chorus && chorus.wet) chorus.wet.value = parseFloat(e.target.value); });
                document.getElementById('delay-slider').addEventListener('input', e => { if (delay && delay.wet) delay.wet.value = parseFloat(e.target.value); });
                document.getElementById('reverb-slider').addEventListener('input', e => { if (reverb && reverb.wet) reverb.wet.value = parseFloat(e.target.value); });
                document.getElementById('bloom-slider').addEventListener('input', e => { if(bloomReverb && bloomReverb.wet) bloomReverb.wet.value = parseFloat(e.target.value); });
                
                let lastGravityTime = 0;
                canvas.addEventListener('mousedown', e => { isDrawing = true; handleInteraction(e); });
                canvas.addEventListener('mousemove', e => { 
                    if(isDrawing) {
                        const now = Date.now();
                        if (currentBrush.includes('gravity') && now - lastGravityTime > 30) {
                            handleInteraction(e);
                            lastGravityTime = now;
                        } else if (!currentBrush.includes('gravity')) {
                            handleInteraction(e);
                        }
                    }
                });
                canvas.addEventListener('mouseup', () => { isDrawing = false; });
                canvas.addEventListener('mouseleave', () => { isDrawing = false; });

                function handleInteraction(e) {
                    const rect = canvas.getBoundingClientRect();
                    const x = (e.clientX - rect.left) / cellSize;
                    const y = (e.clientY - rect.top) / cellSize;
                    const gridX = Math.floor(x);
                    const gridY = Math.floor(y);

                    if (currentBrush === 'draw') {
                        if (gridX >= 0 && gridX < gridWidth && gridY >= 0 && gridY < gridHeight) {
                            grid[gridY][gridX] = { species: activeSpecies, age: 1 }; 
                        }
                    } else if (patterns[currentBrush]) {
                        stampPattern(gridX, gridY, patterns[currentBrush], activeSpecies);
                    } else if (currentBrush === 'gravity' || currentBrush === 'anti-gravity') {
                        applyGravity(gridX, gridY);
                    }
                }

                function applyGravity(cx, cy) {
                    const radius = 8;
                    for (let y = cy - radius; y <= cy + radius; y++) {
                        for (let x = cx - radius; x <= cx + radius; x++) {
                            const gX = (x + gridWidth) % gridWidth;
                            const gY = (y + gridHeight) % gridHeight;
                            const cell = grid[gY][gX];
                            if (!cell) continue;

                            const dx = cx - gX;
                            const dy = cy - gY;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            if (dist < radius && dist > 0) {
                                let bestNeighbor = null;
                                let bestDist = currentBrush === 'gravity' ? Infinity : -Infinity;
                                for (let ny = -1; ny <= 1; ny++) {
                                    for (let nx = -1; nx <= 1; nx++) {
                                        if (ny === 0 && nx === 0) continue;
                                        const targetX = (gX + nx + gridWidth) % gridWidth;
                                        const targetY = (gY + ny + gridHeight) % gridHeight;

                                        if (!grid[targetY][targetX]) {
                                            const neighborDist = Math.sqrt(Math.pow(cx - targetX, 2) + Math.pow(cy - targetY, 2));
                                            if (currentBrush === 'gravity' && neighborDist < bestDist) {
                                                bestDist = neighborDist;
                                                bestNeighbor = { x: targetX, y: targetY };
                                            } else if (currentBrush === 'anti-gravity' && neighborDist > bestDist) {
                                                bestDist = neighborDist;
                                                bestNeighbor = { x: targetX, y: targetY };
                                            }
                                        }
                                    }
                                }
                                if (bestNeighbor) {
                                    grid[bestNeighbor.y][bestNeighbor.x] = cell;
                                    grid[gY][gX] = null;
                                }
                            }
                        }
                    }
                }

                function stampPattern(x, y, pattern, species) {
                    const pHeight = pattern.length;
                    const pWidth = pattern[0].length;
                    const startX = x - Math.floor(pWidth / 2);
                    const startY = y - Math.floor(pHeight / 2);
                    for (let i = 0; i < pHeight; i++) {
                        for (let j = 0; j < pWidth; j++) {
                            if (pattern[i][j] === 1) {
                                const gX = (startX + j + gridWidth) % gridWidth;
                                const gY = (startY + i + gridHeight) % gridHeight;
                                grid[gY][gX] = { species: species, age: 1 };
                            }
                        }
                    }
                }
            }
        });
    </script>
</body>
</html>
